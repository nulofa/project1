<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../static/css/style0.css">
    <title>D3:Scatter Plot</title>
    <link href="../static/new_css/css/bootstrap.css" rel="stylesheet" type="text/css" media="all" />
<link href="../static/new_css/css/style.css" rel="stylesheet" type="text/css" media="all" />
<!-- js -->
<script src="../static/new_css/js/jquery-1.11.1.min.js"></script>
<!-- //js -->
{#<link href='http://fonts.useso.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>#}
{#<link href='http://fonts.useso.com/css?family=Archivo+Narrow:400,400italic,700,700italic' rel='stylesheet' type='text/css'>#}
 <link rel="stylesheet" href="../static/css/w3.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat">
<link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
<link rel="stylesheet" href="../static/css/fontawesome.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

</head>

<body style="margin: 0 auto">

<div class="banner1">
    <br><br><br>
		<div class="container" >
<!-- header -->



     <div class="jumbotron">
    <div id = 'text' class="legend2"></div>

    <div id="dataviz_axisZoom" >
        <div id="legend" class="legend">
            <div class="text">
              search results
              <div class="box firebrick"></div>
            </div>
            <div class="text">
               Others
              <div class="box yellowgreen"></div>
            </div>
      </div>
    </div>
        </div>

    <script src="https://d3js.org/d3.v5.min.js"></script>
        </div>
</div>

{#    <script src="../static/js/app0.js"></script>#}
{#    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>#}
<script>
    const tooltip = document.getElementById('tooltip');

{#fetch('../static/'+'data'+'{{ip}}'+'.json')#}
{#  .then(res => res.json())#}
{#  .then(res => {#}
{##}
{#  createStuff(res.map(r => [#}
{#    // convertMinAndSec(r.Time),#}
{#    // r.Year,#}
{#    // r.Doping,#}
{#// r.Name#}
{#      parseFloat(r.x),#}
{#      parseFloat(r.y),#}
{#      r.similar,#}
{#      r.Title,#}
{#      r.Characteristics,#}
{#      r.Accesion_number,#}
{#      r.spearman#}
{#  ]));#}
{#});#}
    var res = {{ dataj|safe }};
    createStuff(res.map(r => [
      parseFloat(r.x),
      parseFloat(r.y),
      r.similar,
      r.Title,
      r.Characteristics,
      r.Accesion_number,
      r.spearman
  ]));
// function convertMinAndSec(str) {
//   return new Date(`2010 01 01 00:${str}`);
// }


function createInnerHTMLForTooltip(d) {
  return `
    <p2><strong>Accesion number: </strong><br>${d[5]}<br></p2>
    <p2><strong>Spearman correclation: </strong><br>${d[6]}<br></p2>
    <p2><strong>Title: </strong><br>${d[3]}<br></p2>
    <p2><strong>Characteristics: </strong><br>${d[4]}</p2>
    <br><br>
  `;
}


// append the SVG object to the body of the page


//Read the data
function createStuff(data) {
    var margin = {top: 40, right: 30, bottom: 30, left: 60},
    width = 700 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;
    var zoom = d3.zoom()
      .scaleExtent([0.5, 50])  // This control how much you can unzoom (x0.5) and zoom (x20)
      .extent([[0, 0], [width, height]])
      .on("zoom", updateChart);

    var SVG = d3.select("#dataviz_axisZoom")
  .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")")


SVG.append("rect")
  .attr("width", width)
  .attr("height", height)
  .attr("class", "plot")
.style("fill","transparent" )
    .call(zoom);

  // Add X axis
  var x = d3.scaleLinear()
    .domain([d3.min(data, d => d[0]), d3.max(data, d => d[0])])
    .range([ 0, width ]);
  var xAxis = SVG.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x));

  // Add Y axis
  var y = d3.scaleLinear()
    .domain([d3.min(data, d => d[1]), d3.max(data, d => d[1])])
    .range([ height, 0]);
  var yAxis = SVG.append("g")
    .call(d3.axisLeft(y));

  // Add a clipPath: everything out of this area won't be drawn.
  var clip = SVG.append("defs").append("SVG:clipPath")
      .attr("id", "clip")
      .append("SVG:rect")
      .attr("width", width )
      .attr("height", height )
      .attr("x", 0)
      .attr("y", 0);

  // Create the scatter variable: where both the circles and the brush take place
  var scatter = SVG.append('g')
    .attr("clip-path", "url(#clip)")

  // Add circles
  scatter
    .selectAll("circle")
    .data(data)
    .enter()
    .append("circle")
      .attr('s', 'black')
    .attr('cx', d => x(d[0]))
    .attr('cy', d => y(d[1]))
      .attr("r", 5)
      .attr('stroke', 'gray')
      .attr('fill', d => d[2] === '' ? 'yellowgreen' : 'firebrick')
      .attr("r",5)
        .on('mouseover', (d, i) => {


     var showDiv = document.getElementById('text');

     showDiv.innerHTML = createInnerHTMLForTooltip(d);
  })
  {#    .on('mouseout', () => {#}
  {#    var showDiv = document.getElementById('text');#}
  {##}
  {#   showDiv.innerHTML = '';#}
  {#});#}


  // Set the zoom and Pan features: how much you can zoom, on which part, and what to do when there is a zoom


  // This add an invisible rect on top of the chart area. This rect can recover pointer events: necessary to understand when the user zoom
  {#SVG.append("rect")#}
  {#    .attr("width", width)#}
  {#    .attr("height", height)#}
  {#    .style("fill", "transparent")#}
  {#    .style("pointer-events", "all")#}
  {#    .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')#}







  // now the user can zoom and it will trigger the function called updateChart

  // A function that updates the chart when the user zoom and thus new boundaries are available
  function updateChart() {

    // recover the new scale
    var newX = d3.event.transform.rescaleX(x);
    var newY = d3.event.transform.rescaleY(y);


    // update axes with these new boundaries
    xAxis.call(d3.axisBottom(newX))
    yAxis.call(d3.axisLeft(newY))

    // update circle position
    scatter
      .selectAll("circle")
      .attr('cx', function (d) { return newX(d[0]); } )
      .attr('cy',function (d) { return newY(d[1]); } );
  }

}

//-----------------
{#function createStuff(data) {#}
{#  const width = 900;#}
{#  const height = 500;#}
{#  const padding = 80;#}
{##}
{#  const circleRadius = 4;#}
{##}
{#  // const yScale = d3.scaleTime()#}
{#  //     .domain([d3.min(data, d => d[0]), d3.max(data, d => d[0])])#}
{#  //     .range([padding, height - padding]);#}
{#  const yScale= d3#}
{#        .scaleLinear()#}
{#        .domain([d3.min(data, d => d[0])-10, d3.max(data, d => d[0])]) // input#}
{#        .range([padding, height - padding]);#}
{##}
{#  const xScale =d3#}
{#        .scaleLinear()#}
{#        .domain([d3.min(data, d => d[1]), d3.max(data, d => d[1])]) // input#}
{#        .range([padding, width - padding]);#}
{##}
{#  // const xScale = d3.scaleTime()#}
{#  //     .domain([#}
{#  //       d3.min(data, d => new Date(d[1] - 1)),#}
{#  //       d3.max(data, d => new Date(d[1] + 1))#}
{#  //     ])#}
{#  //     .range([padding, width - padding]);#}
{##}
{#  console.log(d3.max(data, d => d[1]));#}
{#  console.log(d3.max(data, d => d[0]));#}
{#  console.log('{{ip }}');#}
{##}
{##}
{##}
{##}
{##}
{#  const svg = d3.select('#container').append('svg')#}
{#          .attr('width', width)#}
{#          .attr('height', height)#}
{#		.call(d3.zoom().scaleExtent([1, 4]).on("zoom", function () {#}
{#        svg.attr("transform", d3.event.transform)#}
{#     }))#}
{##}
{##}
{#  // create the graph#}
{#  svg.selectAll('circle')#}
{#    .data(data)#}
{#    .enter()#}
{#    .append('circle')#}
{#    .attr('class', 'dot')#}
{#    .attr('data-xvalue', d => d[1])#}
{#    .attr('data-yvalue', d => d[0])#}
{#    .attr('cx', d => xScale(d[1]))#}
{#    .attr('cy', d => yScale(d[0]))#}
{#    .attr('fill', d => d[2] === '' ? 'yellowgreen' : 'firebrick')#}
{#    .attr('stroke', 'black')#}
{#    .attr('r', circleRadius)#}
{#    .on('mouseover', (d, i) => {#}
{#      tooltip.classList.add('show');#}
{#      tooltip.style.left = xScale(d[1]) + 10 + 'px';#}
{##}
{#      tooltip.style.top = yScale(d[0]) - 10 + 'px';#}
{##}
{#      // tooltip.setAttribute('data-year', d[1])#}
{##}
{#      tooltip.innerHTML = createInnerHTMLForTooltip(d);#}
{#  }).on('mouseout', () => {#}
{#     tooltip.classList.remove('show');#}
{#  })#}
{#  .call(d3.drag()#}
{#        .on("drag", dragged));#}
{##}
{#  function dragged(d) {#}
{#  d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);#}


  // format the data
  // const timeFormatForMinAndSec = d3.timeFormat("%M:%S");
  // const timeFormatForYear = d3.format("d");

  // create axis
{#  const xAxis = d3.axisBottom(xScale)#}
{#    .scale(xScale)#}
{#  const yAxis = d3.axisLeft(yScale)#}
{#    .scale(yScale)#}
{##}
{#  svg.append('g')#}
{#    .attr('id', 'x-axis')#}
{#    .attr('transform', `translate(0, ${height - padding})`)#}
{#    .call(xAxis);#}
{##}
{#  svg.append('g')#}
{#    .attr('id', 'y-axis')#}
{#    .attr('transform', `translate(${padding}, 0)`)#}
{#    .call(yAxis)#}
{##}
{#}#}
</script>

</body>



</html>